"use strict";

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _assert = _interopRequireDefault(require("assert"));

var _ = _interopRequireDefault(require("../"));

var _identifierReversePlugin = _interopRequireDefault(require("./helpers/identifier-reverse-plugin"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var babel = require('@babel/core');

var errorSpy, describeSpy, itSpy, itOnlySpy, itSkipSpy, equalSpy, transformSpy, writeFileSyncSpy, pendingTests;

var noop = function noop() {}; // eslint-disable-next-line require-await


var promiseWrap =
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(function* (fn) {
    return fn();
  });

  return function promiseWrap(_x) {
    return _ref.apply(this, arguments);
  };
}();

var describeMock = function describeMock(title, body) {
  body();
};

var titleTesterMock = function titleTesterMock(title, testFn) {
  pendingTests.push(promiseWrap(testFn));
};

var simpleTest = 'var hi = "hey";';

var runPluginTester =
/*#__PURE__*/
function () {
  var _ref2 = _asyncToGenerator(function* () {
    pendingTests = [];

    try {
      _.default.apply(void 0, arguments);

      return yield Promise.all(pendingTests);
    } finally {
      pendingTests = [];
    }
  });

  return function runPluginTester() {
    return _ref2.apply(this, arguments);
  };
}();

beforeEach(function () {
  equalSpy = jest.spyOn(_assert.default, 'equal');
  errorSpy = jest.spyOn(console, 'error').mockImplementation(noop);
  describeSpy = jest.spyOn(global, 'describe').mockImplementation(describeMock);
  itSpy = jest.spyOn(global, 'it').mockImplementation(titleTesterMock);
  global.it.only = jest.fn(titleTesterMock);
  global.it.skip = jest.fn(titleTesterMock);
  itOnlySpy = global.it.only;
  itSkipSpy = global.it.skip;
  transformSpy = jest.spyOn(babel, 'transform');
  writeFileSyncSpy = jest.spyOn(_fs.default, 'writeFileSync').mockImplementation(function () {});
});
afterEach(function () {
  equalSpy.mockRestore();
  errorSpy.mockRestore();
  describeSpy.mockRestore();
  itSpy.mockRestore();
  itSkipSpy.mockRestore();
  transformSpy.mockRestore();
  writeFileSyncSpy.mockRestore();
});
test('plugin is required',
/*#__PURE__*/
_asyncToGenerator(function* () {
  yield expect(runPluginTester()).rejects.toThrowErrorMatchingSnapshot();
}));
test('logs when plugin name is not inferable and rethrows errors',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var error = new Error('hey there');
  yield expect(runPluginTester({
    plugin: function plugin() {
      throw error;
    }
  })).rejects.toThrow(error);
  expect(errorSpy).toHaveBeenCalledTimes(1);
  expect(errorSpy).toHaveBeenCalledWith(expect.stringMatching(/infer.*name.*plugin/));
}));
test('throws an invariant if the plugin name is not inferable',
/*#__PURE__*/
_asyncToGenerator(function* () {
  yield expect(runPluginTester({
    plugin: function plugin() {
      return {};
    }
  })).rejects.toThrowErrorMatchingSnapshot();
}));
test('exists early if no tests are supplied',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var _getOptions = getOptions(),
      plugin = _getOptions.plugin;

  yield runPluginTester({
    plugin
  });
  expect(describeSpy).not.toHaveBeenCalled();
  expect(itSpy).not.toHaveBeenCalled();
}));
test('exits early if tests is an empty array',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var _getOptions2 = getOptions(),
      plugin = _getOptions2.plugin;

  yield runPluginTester({
    plugin,
    tests: []
  });
  expect(describeSpy).not.toHaveBeenCalled();
  expect(itSpy).not.toHaveBeenCalled();
}));
test('accepts a title for the describe block',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var title = 'describe block title';
  yield runPluginTester(getOptions({
    title
  }));
  expect(describeSpy).toHaveBeenCalledWith(title, expect.any(Function));
}));
test('can infer the plugin name for the describe block',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var name = 'super-great';

  var _getOptions3 = getOptions({
    plugin: function plugin() {
      return {
        name,
        visitor: {}
      };
    }
  }),
      plugin = _getOptions3.plugin,
      tests = _getOptions3.tests;

  yield runPluginTester({
    plugin,
    tests
  });
  expect(describeSpy).toHaveBeenCalledTimes(1);
  expect(describeSpy).toHaveBeenCalledWith(name, expect.any(Function));
}));
test('calls describe and test for a group of tests',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var pluginName = 'supergirl';
  var customTitle = 'some custom title';
  var options = getOptions({
    pluginName,
    tests: [simpleTest, simpleTest, {
      code: simpleTest,
      title: customTitle
    }]
  });
  yield runPluginTester(options);
  expect(describeSpy).toHaveBeenCalledTimes(1);
  expect(describeSpy).toHaveBeenCalledWith(options.pluginName, expect.any(Function));
  expect(itSpy).toHaveBeenCalledTimes(3);
  expect(itSpy.mock.calls).toEqual([[`1. ${pluginName}`, expect.any(Function)], [`2. ${pluginName}`, expect.any(Function)], [`${customTitle}`, expect.any(Function)]]);
}));
test('tests can be skipped',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var _getOptions4 = getOptions(),
      plugin = _getOptions4.plugin;

  yield runPluginTester({
    plugin,
    tests: [{
      skip: true,
      code: '"hey";'
    }]
  });
  expect(itSkipSpy).toHaveBeenCalledTimes(1);
  expect(itSpy).not.toHaveBeenCalled();
}));
test('tests can be only-ed',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var _getOptions5 = getOptions(),
      plugin = _getOptions5.plugin;

  yield runPluginTester({
    plugin,
    tests: [{
      only: true,
      code: '"hey";'
    }]
  });
  expect(itOnlySpy).toHaveBeenCalledTimes(1);
  expect(itSpy).not.toHaveBeenCalled();
}));
test('tests cannot be both only-ed and skipped',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var _getOptions6 = getOptions(),
      plugin = _getOptions6.plugin;

  yield expect(runPluginTester({
    plugin,
    tests: [{
      only: true,
      skip: true,
      code: '"hey";'
    }]
  })).rejects.toThrowErrorMatchingSnapshot();
}));
test('default will throw if output changes',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var tests = ['var hello = "hi";'];
  var options = getOptions({
    plugin: _identifierReversePlugin.default,
    tests
  });
  yield snapshotOptionsError(options);
}));
test('skips falsy tests',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var tests = [simpleTest, undefined, null, simpleTest];
  yield runPluginTester(getOptions({
    tests
  }));
  expect(itSpy).toHaveBeenCalledTimes(2);
}));
test('throws if output is incorrect',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var tests = [{
    code: '"hi";',
    output: '"hey";'
  }];
  yield snapshotOptionsError(getOptions({
    tests
  }));
}));
test(`throws invariant if there's no code`,
/*#__PURE__*/
_asyncToGenerator(function* () {
  var tests = [{}];
  yield snapshotOptionsError(getOptions({
    tests
  }));
}));
test('trims and deindents code and output',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var tests = [{
    code: `
        var someCode = 'cool';
      `,
    output: `
        var someCode = 'cool';
      `
  }];
  yield runPluginTester(getOptions({
    tests
  }));
  expect(equalSpy).toHaveBeenCalledWith(`var someCode = 'cool';`, `var someCode = 'cool';`, expect.any(String));
}));
test('accepts an empty output',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var tests = [{
    code: `var eraseMe = 'junk'`,
    output: ''
  }];
  var errorResponse;

  try {
    yield runPluginTester(getOptions({
      plugin: function plugin() {
        return {
          name: 'cleanup',
          visitor: {
            VariableDeclaration(p) {
              p.remove();
            }

          }
        };
      },
      tests
    }));
    errorResponse = false;
  } catch (error) {
    errorResponse = true;
  }

  expect(errorResponse).toEqual(false);
}));
test('can get a code and output fixture that is an absolute path',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var tests = [{
    fixture: getFixturePath('fixture1.js'),
    outputFixture: getFixturePath('outure1.js')
  }];

  try {
    yield runPluginTester(getOptions({
      tests
    }));
  } catch (error) {
    var actual = getFixtureContents('fixture1.js');
    var expected = getFixtureContents('outure1.js');
    expect(error).toMatchObject({
      name: expect.stringMatching(/AssertionError/),
      message: 'Output is incorrect.',
      actual,
      expected
    });
  }
}));
test('can pass with fixture and outputFixture',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var tests = [{
    fixture: getFixturePath('fixture1.js'),
    outputFixture: getFixturePath('fixture1.js')
  }];
  yield runPluginTester(getOptions({
    tests
  }));
}));
test('throws error if fixture provided and code changes',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var tests = [{
    fixture: getFixturePath('fixture1.js')
  }];
  yield snapshotOptionsError(getOptions({
    plugin: _identifierReversePlugin.default,
    tests
  }));
}));
test('can resolve a fixture with the filename option',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var tests = [{
    fixture: 'fixtures/fixture1.js',
    outputFixture: 'fixtures/outure1.js'
  }];

  try {
    yield runPluginTester(getOptions({
      filename: __filename,
      tests
    }));
  } catch (error) {
    var actual = getFixtureContents('fixture1.js');
    var expected = getFixtureContents('outure1.js');
    expect(error).toMatchObject({
      name: expect.stringMatching(/AssertionError/),
      message: 'Output is incorrect.',
      actual,
      expected
    });
  }
}));
test('can pass tests in fixtures relative to the filename',
/*#__PURE__*/
_asyncToGenerator(function* () {
  yield runPluginTester(getOptions({
    filename: __filename,
    fixtures: 'fixtures/fixtures',
    tests: null
  }));
  expect(describeSpy).toHaveBeenCalledTimes(5);
  expect(itSpy).toHaveBeenCalledTimes(8);
  expect(itSpy.mock.calls).toEqual([[`changed`, expect.any(Function)], [`nested a`, expect.any(Function)], [`nested b`, expect.any(Function)], [`typescript`, expect.any(Function)], [`unchanged`, expect.any(Function)], [`nested with option`, expect.any(Function)], [`nested without option`, expect.any(Function)], [`without output file`, expect.any(Function)]]);
}));
test('can fail tests in fixtures at an absolute path',
/*#__PURE__*/
_asyncToGenerator(function* () {
  try {
    yield runPluginTester(getOptions({
      plugin: _identifierReversePlugin.default,
      tests: null,
      fixtures: getFixturePath('failing-fixtures')
    }));
  } catch (error) {
    expect(error.message).toMatchSnapshot();
  }
}));
test('creates output file for new tests',
/*#__PURE__*/
_asyncToGenerator(function* () {
  yield runPluginTester(getOptions({
    filename: __filename,
    fixtures: 'fixtures/fixtures',
    tests: null
  }));
  expect(writeFileSyncSpy.mock.calls[0]).toEqual([expect.stringMatching(/(\/|\\)output\.(j|t)s$/), "'use strict';"]);
}));
test('uses the fixture filename in babelOptions',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var fixture = getFixturePath('fixture1.js');
  var tests = [{
    fixture,
    outputFixture: getFixturePath('fixture1.js')
  }];
  yield runPluginTester(getOptions({
    tests
  }));
  expect(transformSpy).toHaveBeenCalledTimes(1);
  expect(transformSpy).toHaveBeenCalledWith(expect.any(String), expect.objectContaining({
    filename: fixture
  }));
}));
test('allows for a test babelOptions can provide a filename',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var filename = getFixturePath('outure1.js');
  var tests = [{
    babelOptions: {
      filename
    },
    fixture: getFixturePath('fixture1.js'),
    outputFixture: getFixturePath('fixture1.js')
  }];
  yield runPluginTester(getOptions({
    tests
  }));
  expect(transformSpy).toHaveBeenCalledTimes(1);
  expect(transformSpy).toHaveBeenCalledWith(expect.any(String), expect.objectContaining({
    filename
  }));
}));
test('can provide a test filename for code strings',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var filename = getFixturePath('outure1.js');
  var tests = [{
    babelOptions: {
      filename
    },
    code: simpleTest
  }];
  yield runPluginTester(getOptions({
    tests
  }));
  expect(transformSpy).toHaveBeenCalledTimes(1);
  expect(transformSpy).toHaveBeenCalledWith(expect.any(String), expect.objectContaining({
    filename
  }));
}));
test('can provide plugin options',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var tests = [simpleTest];
  var pluginOptions = {
    optionA: true
  };
  yield runPluginTester(getOptions({
    tests,
    pluginOptions
  }));
  expect(transformSpy).toHaveBeenCalledTimes(1);
  expect(transformSpy).toHaveBeenCalledWith(expect.any(String), expect.objectContaining({
    plugins: expect.arrayContaining([[expect.any(Function), expect.objectContaining({
      optionA: true
    })]])
  }));
}));
test('can overwrite plugin options at test level',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var pluginOptions = {
    optionA: false
  };
  var tests = [{
    code: simpleTest,
    pluginOptions
  }];
  yield runPluginTester(getOptions({
    tests,
    pluginOptions: {
      optionA: true
    }
  }));
  expect(transformSpy).toHaveBeenCalledTimes(1);
  expect(transformSpy).toHaveBeenCalledWith(expect.any(String), expect.objectContaining({
    plugins: expect.arrayContaining([[expect.any(Function), expect.objectContaining({
      optionA: false
    })]])
  }));
}));
test('throws invariant if snapshot and output are both provided',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var tests = [{
    code: simpleTest,
    output: 'anything',
    snapshot: true
  }];
  yield snapshotOptionsError(getOptions({
    tests
  }));
}));
test('snapshot option can be derived from the root config',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var tests = [{
    code: simpleTest,
    output: 'anything'
  }];
  yield snapshotOptionsError(getOptions({
    snapshot: true,
    tests
  }));
}));
test('throws invariant if code is unchanged + snapshot enabled',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var tests = [simpleTest];
  yield snapshotOptionsError(getOptions({
    snapshot: true,
    tests
  }));
}));
test('takes a snapshot',
/*#__PURE__*/
_asyncToGenerator(function* () {
  // this one is kinda tricky... At first I thought I'd mock toMatchSnapshot
  // but then I realized that we can actually use it to our advantage in
  // this case. We actually _do_ take a snapshot and that makes our test
  // work pretty well soooooo... ðŸ˜€
  var tests = [simpleTest];
  yield runPluginTester(getOptions({
    snapshot: true,
    tests,
    plugin: _identifierReversePlugin.default
  }));
}));
test('can provide an object for tests',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var firstTitle = 'first title';
  var secondTitle = 'second title';
  var tests = {
    [firstTitle]: simpleTest,
    [secondTitle]: {
      code: simpleTest
    }
  };
  yield runPluginTester(getOptions({
    tests
  }));
  expect(equalSpy).toHaveBeenCalledTimes(2);
  expect(equalSpy.mock.calls).toEqual([[simpleTest, simpleTest, expect.any(String)], [simpleTest, simpleTest, expect.any(String)]]);
  expect(itSpy.mock.calls).toEqual([[firstTitle, expect.any(Function)], [secondTitle, expect.any(Function)]]);
}));
test('can capture errors with true', function () {
  return testPluginError(true);
});
test('can capture errors with Error constructor', function () {
  return testPluginError(SyntaxError);
});
test('can capture errors with string', function () {
  return testPluginError('test message');
});
test('can capture errors with regex', function () {
  return testPluginError(/mess/);
});
test('can capture errors with function', function () {
  return testPluginError(function (err) {
    return /mess/.test(err.message) && err instanceof SyntaxError;
  });
});
test(`throws error when function doesn't return true`, function () {
  return snapshotPluginError(function () {
    return false;
  });
});
test('throws error when error expected but no error thrown', function () {
  return snapshotPluginError(true, {
    plugin: function plugin() {
      return {};
    }
  });
});
test('throws error if there is a problem parsing',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var error;

  try {
    yield runPluginTester(getOptions({
      tests: [`][fkfhgo]fo{r`],
      babelOptions: {
        filename: __filename
      }
    }));
  } catch (e) {
    error = e;
  }

  expect(error.constructor).toBe(SyntaxError);
  expect(error.message).toContain('Unexpected token (1:0)');
}));
test(`throws an error if babelrc is true with no filename`, function () {
  var tests = ['"use strict";'];
  snapshotOptionsError(getOptions({
    tests,
    babelOptions: {
      babelrc: true
    }
  }));
});
test('runs test setup function',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var setupSpy = jest.fn();
  var tests = [{
    code: simpleTest,
    setup: setupSpy
  }];
  yield runPluginTester(getOptions({
    tests
  }));
  expect(setupSpy).toHaveBeenCalledTimes(1);
}));
test('runs test teardown function',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var teardownSpy = jest.fn();
  var tests = [{
    code: simpleTest,
    teardown: teardownSpy
  }];
  yield runPluginTester(getOptions({
    tests
  }));
  expect(teardownSpy).toHaveBeenCalledTimes(1);
}));
test('setup can return a teardown function',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var teardownSpy = jest.fn();
  var setupSpy = jest.fn(function () {
    return teardownSpy;
  });
  var tests = [{
    code: simpleTest,
    setup: setupSpy
  }];
  yield runPluginTester(getOptions({
    tests
  }));
  expect(teardownSpy).toHaveBeenCalledTimes(1);
}));
test('function resolved from setup promise used for teardown',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var teardownSpy = jest.fn();
  var setupSpy = jest.fn(function () {
    return Promise.resolve(teardownSpy);
  });
  var tests = [{
    code: simpleTest,
    setup: setupSpy
  }];
  yield runPluginTester(getOptions({
    tests
  }));
  expect(teardownSpy).toHaveBeenCalledTimes(1);
}));
test('error logged and thrown if setup throws',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var errorToThrow = new Error('blah');
  var setupSpy = jest.fn(function () {
    throw errorToThrow;
  });
  var tests = [{
    code: simpleTest,
    setup: setupSpy
  }];
  var errorThrown = yield runPluginTester(getOptions({
    tests
  })).catch(function (e) {
    return e;
  });
  expect(errorThrown).toBe(errorToThrow);
  expect(errorSpy).toHaveBeenCalledWith(expect.stringMatching(/problem.*setup/i));
}));
test('error logged and thrown if teardown throws',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var errorToThrow = new Error('blah');
  var teardownSpy = jest.fn(function () {
    throw errorToThrow;
  });
  var tests = [{
    code: simpleTest,
    teardown: teardownSpy
  }];
  var errorThrown = yield runPluginTester(getOptions({
    tests
  })).catch(function (e) {
    return e;
  });
  expect(errorThrown).toBe(errorToThrow);
  expect(errorSpy).toHaveBeenCalledWith(expect.stringMatching(/problem.*teardown/i));
}));
test('allows formatting the result',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var formatResultSpy = jest.fn(function (r) {
    return r;
  });
  yield runPluginTester(getOptions({
    tests: [{
      code: simpleTest,
      formatResult: formatResultSpy
    }]
  }));
  expect(formatResultSpy).toHaveBeenCalledTimes(1);
  expect(formatResultSpy).toHaveBeenCalledWith(simpleTest);
}));
test('allows formatting fixtures results',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var formatResultSpy = jest.fn(function (r) {
    return r;
  });
  yield runPluginTester(getOptions({
    fixtures: getFixturePath('fixtures'),
    formatResult: formatResultSpy
  }));
  expect(formatResultSpy).toHaveBeenCalledTimes(9);
}));
test('gets options from options.json files when using fixtures',
/*#__PURE__*/
_asyncToGenerator(function* () {
  var optionRootFoo = jest.fn();
  var optionFoo = jest.fn();
  var optionBar = jest.fn();
  var pluginWithOptions = jest.fn(function () {
    return {
      visitor: {
        Program(programPath, state) {
          if (state.opts.rootFoo === 'rootBar') {
            optionRootFoo();
          }

          if (state.opts.foo === 'bar') {
            optionFoo();
          }

          if (state.opts.bar === 'baz') {
            optionBar();
          }
        }

      }
    };
  });
  yield runPluginTester(getOptions({
    plugin: pluginWithOptions,
    fixtures: getFixturePath('fixtures')
  }));
  expect(optionRootFoo).toHaveBeenCalledTimes(8);
  expect(optionFoo).toHaveBeenCalledTimes(2);
  expect(optionBar).toHaveBeenCalledTimes(1);
}));

function getOptions(overrides) {
  return _objectSpread({
    pluginName: 'captains-log',
    plugin: function plugin() {
      return {
        name: 'captains-log',
        visitor: {}
      };
    },
    tests: [simpleTest]
  }, overrides);
}

function getFixtureContents(fixture) {
  var fullPath = getFixturePath(fixture);
  return _fs.default.readFileSync(fullPath, 'utf8').trim();
}

function getFixturePath() {
  var fixture = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return _path.default.join(__dirname, 'fixtures', fixture);
}

function snapshotOptionsError(_x2) {
  return _snapshotOptionsError.apply(this, arguments);
}

function _snapshotOptionsError() {
  _snapshotOptionsError = _asyncToGenerator(function* (options) {
    var error;

    try {
      yield runPluginTester(options);
    } catch (e) {
      error = e;
    }

    expect(error.message).toMatchSnapshot();
  });
  return _snapshotOptionsError.apply(this, arguments);
}

function snapshotPluginError(_x3, _x4) {
  return _snapshotPluginError.apply(this, arguments);
}

function _snapshotPluginError() {
  _snapshotPluginError = _asyncToGenerator(function* (error, overrides) {
    var errorThrown;

    try {
      yield testPluginError(error, overrides);
    } catch (e) {
      errorThrown = e;
    }

    expect(errorThrown.message).toMatchSnapshot();
  });
  return _snapshotPluginError.apply(this, arguments);
}

function testPluginError(error, overrides) {
  return runPluginTester(getOptions(_objectSpread({
    plugin: function plugin() {
      throw new SyntaxError('test message');
    },
    tests: [{
      code: simpleTest,
      error
    }]
  }, overrides)));
}